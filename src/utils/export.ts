// Export utilities for Arduboy sprite format

import { SpriteData, ExportOptions } from '../types';

export function exportSprite(
  sprite: SpriteData,
  options: ExportOptions
): string {
  const { format, includeDimensions, includeFrameCount, variableName } =
    options;

  let output = "";

  // Add header comment
  output += `// Generated by Arduboy Sprite Editor\n`;
  output += `// Sprite: ${sprite.name}\n`;
  output += `// Dimensions: ${sprite.width}x${sprite.height}\n`;

  if (sprite.isAnimation && sprite.frames) {
    output += `// Frames: ${sprite.frames.length}\n`;
  }

  output += `\n`;

  // Add includes if needed (removed as requested)
  // if (format === 'progmem') {
  //   output += `#include <avr/pgmspace.h>\n\n`;
  // }

  // Convert sprite to byte array
  const byteArray =
    sprite.isAnimation && sprite.frames
      ? convertAnimationToBytes(sprite)
      : convertSpriteToBytes(sprite.pixels);

  // Generate array declaration
  const arrayType =
    format === "progmem" ? "const unsigned char" : "const uint8_t";
  const memorySpecifier = format === "progmem" ? " PROGMEM" : "";

  output += `${arrayType} ${variableName}[]${memorySpecifier} = {\n`;

  // Add dimensions if requested
  if (includeDimensions) {
    output += `  // Width, Height\n`;
    output += `  ${sprite.width}, ${sprite.height},\n`;
  }

  // Add frame count if animation
  if (includeFrameCount && sprite.isAnimation && sprite.frames) {
    output += `  // Frame count\n`;
    output += `  ${sprite.frames.length},\n`;
  }

  // Add pixel data
  output += `  // Pixel data\n`;

  const bytesPerLine = 16;
  for (let i = 0; i < byteArray.length; i += bytesPerLine) {
    const line = byteArray.slice(i, i + bytesPerLine);
    const formattedBytes = line.map(
      (byte) => `0x${byte.toString(16).padStart(2, "0").toUpperCase()}`
    );
    output += `  ${formattedBytes.join(", ")}`;

    if (i + bytesPerLine < byteArray.length) {
      output += ",";
    }

    output += "\n";
  }

  output += `};\n\n`;

  // Add helper defines (removed as requested)
  // output += `#define ${variableName.toUpperCase()}_WIDTH ${sprite.width}\n`;
  // output += `#define ${variableName.toUpperCase()}_HEIGHT ${sprite.height}\n`;

  // if (sprite.isAnimation && sprite.frames) {
  //   output += `#define ${variableName.toUpperCase()}_FRAMES ${sprite.frames.length}\n`;
  // }

  return output;
}

function convertSpriteToBytes(pixels: boolean[][]): number[] {
  const height = pixels.length;
  const width = pixels[0].length;
  const bytes: number[] = [];

  // Arduboy uses vertical byte packing (8 pixels per byte, vertically)
  for (let x = 0; x < width; x++) {
    for (let page = 0; page < Math.ceil(height / 8); page++) {
      let byte = 0;

      for (let bit = 0; bit < 8; bit++) {
        const y = page * 8 + bit;
        if (y < height && pixels[y][x]) {
          byte |= 1 << bit;
        }
      }

      bytes.push(byte);
    }
  }

  return bytes;
}

function convertAnimationToBytes(sprite: SpriteData): number[] {
  if (!sprite.frames) return [];

  const allBytes: number[] = [];

  for (const frame of sprite.frames) {
    const frameBytes = convertSpriteToBytes(frame.pixels);
    allBytes.push(...frameBytes);
  }

  return allBytes;
}

export function exportProject(
  sprites: SpriteData[],
  projectName: string,
  projectOptions?: Partial<ExportOptions>
): string {
  let output = "";

  output += `// ${projectName} - Arduboy Sprite Collection\n`;
  output += `// Generated by Arduboy Sprite Editor\n\n`;

  // Only add include if format is progmem and not explicitly disabled
  const format = projectOptions?.format || "progmem";
  if (format === "progmem") {
    // Note: Header include removed as requested
    // output += `#include <avr/pgmspace.h>\n\n`;
  }

  for (const sprite of sprites) {
    const options: ExportOptions = {
      format: format,
      includeDimensions: projectOptions?.includeDimensions ?? true,
      includeFrameCount: sprite.isAnimation || false,
      variableName: sanitizeVariableName(sprite.name),
      compress: false,
    };

    output += exportSprite(sprite, options);
    output += "\n";
  }

  return output;
}

function sanitizeVariableName(name: string): string {
  return name
    .replace(/[^a-zA-Z0-9_]/g, '_')
    .replace(/^[0-9]/, '_$&')
    .toLowerCase();
}

export function generateMetadata(sprites: SpriteData[]): string {
  let metadata = '';
  
  metadata += `// Sprite Metadata\n`;
  metadata += `// Total sprites: ${sprites.length}\n\n`;
  
  for (const sprite of sprites) {
    metadata += `// ${sprite.name}:\n`;
    metadata += `//   Dimensions: ${sprite.width} x ${sprite.height}\n`;
    
    if (sprite.isAnimation && sprite.frames) {
      metadata += `//   Animation frames: ${sprite.frames.length}\n`;
      const totalDuration = sprite.frames.reduce((sum, frame) => sum + (frame.duration || 100), 0);
      metadata += `//   Total duration: ${totalDuration}ms\n`;
    }
    
    const pixelCount = sprite.pixels.flat().filter(p => p).length;
    metadata += `//   Black pixels: ${pixelCount}\n`;
    metadata += `\n`;
  }
  
  return metadata;
}